<?php
/**
 * @file PSFC Orientation module
 */

module_load_include('inc', 'psfc_orientation', 'psfc_orientation.email');
module_load_include('inc', 'psfc_orientation', 'psfc_orientation.token');


/**
 * Implements hook_menu_alter().
 *
 * Remove /user/login and /user/register because we have our own custom
 * /login page.
 */

function psfc_orientation_menu_alter(&$items) {
  unset($items['user/login']);
  unset($items['user/register']);
}

/**
 * Implements hook_permission().
 */
function psfc_orientation_permission() {
  return array(
    'administer psfc orientation' => array(
      'title' => t('administer psfc orientation'),
      'description' => t('Allow user to administer all orientation module settings'),
    ),
    'administer orientation attendance' => array(
      'title' => t('administer orientation attendance'),
      'description' => t('Allow user to change attendance at orientations.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function psfc_orientation_menu() {
  $items = array();

  $items['admin/psfc/orientation'] = array(
    'title' => 'PSFC Orientation Administration',
    'description' => 'Allow coop workers to change orientation settings.',
    'page callback' => 'psfc_orientation_admin_page',
    'access callback' => 'psfc_orientation_access_admin',
    'file' => 'psfc_orientation.admin.inc',
    'weight' => 10,
  );
  $items['admin/psfc/orientation/overview'] = array(
    'title' => 'Orientation Overview',
    'description' => 'Allow coop workers to change orientation settings.',
    'page callback' => 'psfc_orientation_admin_page',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/add-rule'] = array(
    'title' => 'Create Orientation Rule',
    'description' => 'Create a new orientation rule.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_admin_add_rule'),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'psfc_orientation.admin.inc',
    'weight' => 8,
  );
  $items['admin/psfc/orientation/delete-rule/%psfc_orientation_orid'] = array(
    'title' => 'Delete Orientation Rule',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_admin_delete_rule', 4),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_CALLBACK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/edit-rule/%psfc_orientation_orid'] = array(
    'title' => 'Edit Orientation Rule',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_admin_edit_rule', 4),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_CALLBACK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/add-blackout'] = array(
    'title' => 'Create a Blackout date',
    'description' => 'Orientations will not be automatically created on this date.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_add_blackout'),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'psfc_orientation.admin.inc',
    'weight' => 10,
  );
  $items['admin/psfc/orientation/delete-blackout/%psfc_orientation_obid'] = array(
    'title' => 'Delete a Blackout Date',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_delete_blackout', 4),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_CALLBACK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/add-registrant'] = array(
    'title' => 'Manual sign up',
    'description' => 'Admin users can sign up someone who does not have internet access',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_add_registrant'),
    'access callback' => 'psfc_orientation_access_admin',
    'type' => MENU_LOCAL_TASK,
    'file' => 'psfc_orientation.admin.inc',
    'weight' => 11,
  );
  $items['admin/psfc/orientation/psfc-orientation-autocomplete'] = array(
    'title' => 'User email autocomplete',
    'page callback' => 'psfc_orientation_email_autocomplete',
    'access callback' => 'user_access',
    'access callback' => 'psfc_orientation_access_admin',
    'type' => MENU_CALLBACK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/mail'] = array(
    'title' => 'Edit orientation emails',
    'description' => 'Configure default e-mail text for orientation messages.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_mail_settings'),
    'access arguments' => array('administer psfc orientation'),
    'file' => 'psfc_orientation.email.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 12,
  );
  $items['join/orientation/signup/session/%'] = array(
    'title' => 'Review your selection',
    'description' => 'Let the user check the date',
    'access arguments' => array('access content'),
    'page callback' => 'psfc_orientation_signup_session_register',
    'page arguments' => array(4),
    'type' => MENU_CALLBACK,
  );

  $items['login'] = array(
    'title' => 'Sign in',
    'description' => 'Log in or create an account.',
    'page callback' => 'psfc_orientation_login',
    'access arguments' => array('access content'),
    'file' => 'psfc_orientation.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['user/register'] = array(
    'title' => 'Sign in',
    'description' => 'Log in or create an account.',
    'page callback' => 'psfc_orientation_login',
    'access arguments' => array('access content'),
    'file' => 'psfc_orientation.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['join/orientation'] = array(
    'title' => 'Join an orientation',
    'description' => 'Register for an orientation.',
    'page callback' => 'psfc_orientation_join_orientation',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['join/orientation/status'] = array(
    'title' => 'Your Orientation Status',
    'description' => 'Are you signed up for orientation.',
    'page callback' => 'psfc_orientation_status',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['join/orientation/confirm/%/%/%/%'] = array(
    'title' => 'Set registration status',
    'page callback' => 'psfc_orientation_confirm',
    'page arguments' => array(3, 4, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_block_info().
 **/
function psfc_orientation_block_info() {
  $items = array(
    'login_or_create_account' => array(
      'info' => t("Login or Create an Account"),
      'region' => 'sidebar_first',
      'status' => 1,
     ),
    'overview' => array(
      'info' => t("Overview of Orientation Process"),
      'status' => 1,
      'region' => 'sidebar_first',
    )
  );
  return $items;
}

/**
 * Implements hook_block_info().
 **/
function psfc_orientation_block_view($delta = '') {
  switch($delta) {
    case "login_or_create_account":
      global $user;
      if(empty($user->uid) && $_GET['q'] != 'login') {
        $text = t("Login or Create an Account");
        return array(
          'subject' => t('Account'),
          'content' => l($text, 'login'),

        );
      }
      else {
        $links = array();
        $change_text = t("Change password or edit account details");
        $links[] = l($change_text, 'user/' . $user->uid . '/edit'); 
        $logout_text = t("Logout");
        $links[] = l($logout_text, "user/logout");
        if($node = psfc_orientation_user_has_upcoming_orientation($user)) {
          // They are registered for an orientation. Give them a quick link.
          $your_orts_text = t("See your orientation details");
          $links[] = l($your_orts_text, "join/orientation/status");
        }
        return array(
          'subject' => t('Account'),
          'content' => implode("<br />", $links)
        );
      }
      break;
    case "overview":
      return array(
        'subject' => t("Overview"),
        'content' => psfc_orientation_get_overview_block(),
      );
      break;
  }
}

/**
 * Provide content for the overview block
 */
function psfc_orientation_get_overview_block() {
  $links = array(
    l(t("Are You Required to Pre-Register?"), 'overview/are-you-required-pre-register'),
    l(t("Households at the Coop"), 'overview/households-coop'),
    l(t("Register for an Orientation"), 'join/register'),
    l(t("Provide Proof of Identity & Address"), 'overview/provide-proof-identity-address'),
    l(t("Select a Coop Workslot"), 'overview/select-coop-workslot'),
    l(t("Have a Photo Taken"), 'overview/have-photo-taken'),
    l(t("Make Your Member Payments"), 'overview/make-your-member-payments'),
  );
  return implode("<br />\n", $links);
}

/**
 * User access function for admin pages intended for multiple roles.
 */
function psfc_orientation_access_admin() {
  if (user_access('administer orientation attendance')) {
    return TRUE;
  }
  elseif (user_access('administer psfc orientation')) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_theme().
 */
function psfc_orientation_theme() {
  return array(
    'psfc_orientation_login' => array(
      'variables' => array(),
    ),
    'psfc_orientation_date_table' => array(
      'variables' => array('date' => NULL),
    ),
    'psfc_orientation_status' => array(
      'variables' => array(),
    ),
    'psfc_orientation_crumbs' => array(
      'variables' => array('path' => NULL),
    ),
  );
}

/**
 * Create orientations based on repeat rules
 *
 * This function should be called from the cron job. It will ensure that
 * there is an orientation scheduled for two weeks from the last day of week
 * that is part of each orientation rule. In other words, if the orientation
 * rule is Mondays at 7:30 pm, it will ensure that there is an orientation
 * created two weeks from last Monday, unless it is blackout date or it has
 * already been created.
 *
 **/
function psfc_orientation_create_based_on_repeat_rules() {
  // Create orientation based on repeat rules.
  $query = db_query("SELECT * FROM {psfc_orientation_repeat_rules}");
  while ($result = $query->fetchAssoc()) {
    psfc_orientation_create_based_on_repeat_rule($result);
  }
}

/**
 * Create orientation rule for a given rule.
 */
function psfc_orientation_create_based_on_repeat_rule($result) {
  $day_of_week = $result['day_of_week'];
  $from = strtotime("Last $day_of_week");
  $time = psfc_orientation_split_out_time_of_day($result['time_of_day']);
  $next_ort = psfc_orientation_determine_next_repeat($time, $from);
  if (!psfc_orientation_orientation_exists($next_ort) &&
    !psfc_orientation_orientation_blacked_out($next_ort)) {
    $node_wrapper = psfc_orientation_node_build($result, $next_ort);
    $nid = $node_wrapper->nid->value();
    if ($nid) {
      watchdog('psfc_orientation', 'Added an orientation for: @date, with nid @nid',
        array('@date' => date('Y-m-d H:i:s', $next_ort), '@nid' => $nid), WATCHDOG_NOTICE);
      return $nid;
    }
  }
  return FALSE;
}

/**
 * Delete unconfirmed registrations.
 */
function psfc_orientation_update_unconfirmed() {
  // Update unconfirmed registrations after 48 hours.
  $expires = REQUEST_TIME - (2 * 24 * 60 * 60);
  $sql = "SELECT n.nid AS attendee_nid, n.uid AS uid, ".
    "o.field_orientation_nid_nid AS orientation_nid ".
    "FROM {node} n JOIN {field_data_field_orientation_nid} o " .
    "ON n.nid = o.entity_id AND n.vid = o.revision_id JOIN ".
    "{field_data_field_confirmed_orientation} con ".
    "ON n.nid = con.entity_id AND n.vid = con.revision_id ".
    "LEFT JOIN field_data_field_canceled_orientation can ".
    "ON n.nid = can.entity_id AND n.vid = can.revision_id ".
    "WHERE n.type = 'orientation_attendee' AND ".
    "n.created < :created AND con.field_confirmed_orientation_value = 0 ".
    "AND can.field_canceled_orientation_value != 1";
  $result = db_query($sql, array(':created' => $expires));
  while ($attendee = $result->fetchAssoc()) {
    $account = user_load($attendee['uid'], TRUE);
    $account_wrapper = entity_metadata_wrapper('user', $account);
    // Make sure the account still exists.
    if (is_object($account)) {
      // Record non-confirmation in orientation node.
      $attendee_node = node_load($attendee['attendee_nid']);

      // Send missed confirmation window mail.
      $recipient = $account->mail;
      $params['node'] = $attendee_node;
      drupal_mail('psfc_orientation', 'confirmation_window_missed', $recipient, language_default(), $params);

      //  Cancel registration (which should update orientation node).
      psfc_orientation_cancel_registration($attendee['attendee_nid']);
    }
  }
}
/**
 * Implemetation of hook_cron().
 */
function psfc_orientation_cron() {
  psfc_orientation_create_based_on_repeat_rules();
  psfc_orientation_update_unconfirmed();
  psfc_orientation_send_reminders();
  psfc_orientation_past_blackout_delete();
  psfc_orientation_close_orientations_starting_in_two_hours();
}

/**
 * Find and close any orientation starting in less than 2 hours
 *
 * Avoids people signing up at the last minute and then being late.
 */
function psfc_orientation_close_orientations_starting_in_two_hours() {
  // Find orientations starting in less than two hours.
  $sql = "SELECT n.nid AS nid FROM {node} n JOIN
    {field_data_field_orientation_closed} c
    ON n.nid = c.entity_id AND n.vid = c.revision_id JOIN
    {field_data_field_orientation_date} d
    ON n.nid = d.entity_id AND n.vid = d.revision_id
    WHERE
    field_orientation_closed_value = 0 AND
    field_orientation_date_value < :end_date";
  // Two hours from now (keeping in mind that times are stored in UTC in the database).
  $end_date = gmdate('Y-m-d H:i:s', time() + (60 * 120));
  $result = db_query($sql, array(':end_date' => $end_date));
  while ($nid = $result->fetchField()) {
    $node = node_load($nid);
    $node_wrapper = entity_metadata_wrapper('node', $node);
    $node_wrapper->field_orientation_closed->set(1);
    $node_wrapper->save();
  }
}

/**
 * Implements hook_user_load().
 */
function psfc_orientation_user_load($users) {
  foreach ($users as $uid => $account) {
    // Add member statuses to the user object.
    if ($attendee = psfc_orientation_get_attendee_node($account)) {
      $users[$uid]->member_status['orientation']['registered'] = TRUE;
      $users[$uid]->member_status['orientation']['confirmed'] = $attendee->field_confirmed_orientation['und'][0]['value'];
      $users[$uid]->member_status['orientation']['attended'] = $attendee->field_attended_orientation['und'][0]['value'];
    }
    else {
      $users[$uid]->member_status['orientation']['registered'] = FALSE;
    }
  }
}

/**
 * Implements hook_user_cancel().
 */
function psfc_orientation_user_cancel($edit, $account, $method) {
  // The table won't exist if no reccords have been created.
  if(db_table_exists('content_type_orientation_attendee')) {
    // When users are deleted, we delete their attendee nodes if they have any.
    $result = db_query("SELECT nid from {content_type_orientation_attendee} WHERE field_userid_uid = :field_userid_uid",
      array(':field_userid_uid' => $account->uid));
    while ($nid = $result->fetchField()) {
      node_delete($nid);
    }
  }
}

/**
 * Implements hook_user_login().
 */
function psfc_orientation_user_login(&$edit, $account) {
  $ort_status = psfc_orientation_user_orientation_status($account->uid);
  $resetting_password = FALSE;
  if(isset($_REQUEST['form_id']) && $_REQUEST['form_id'] == 'user_pass_reset') {
    $resetting_password = TRUE;
  }
  // If the user is resetting their password don't redirect them, other
  // wise they won't make it to the password reset page.
  if ($ort_status > 0 && !$resetting_password) {
    drupal_goto('join/orientation/status');
  }
}

/**
 * Implements hook_form_alter().
 */
function psfc_orientation_form_alter(&$form, &$form_state, $form_id) {
  if ($form['#theme'] == 'confirm_form') {
    $form['actions']['cancel']['#prefix'] = '<div class="button-rounded red"><span>';
    $form['actions']['cancel']['#suffix'] = '</span></div>';
  }
  switch ($form_id) {
    case 'user_login':
      $form['submit']['#value'] = 'Sign In'; // Change button value.
      foreach (element_children($form) as $field) {
        unset($form[$field]['#description']);
      }
      break;
    case 'user_register_form':
      // Only alter reg form on our custom signup page.
      if ($_GET['q'] == 'login') {
        $form['actions']['submit']['#value'] = t('Sign Up'); // Change button value.
      }

      break;
    case 'views_form_orientation_attendees_page_1':
      if (array_key_exists('recipient', $form)) {
        $form['recipient']['#default_value'] = '[psfc:mail]';
      }
      break;
    case 'user_profile_form':
      array_push($form['#submit'], 'psfc_orientation_user_profile_submit');
      break;
  }
}

/**
 * Redirect user when they save their profile.
 *
 * The first thing a new user should do is reset their password. After they 
 * do that we want them redirected to choose an orientation.
 */
function psfc_orientation_user_profile_submit(&$form, &$form_state) {
  global $user;
  $ort_status = psfc_orientation_user_orientation_status($user->uid);
  if ($ort_status > 0)  {
    $form_state['redirect'] = 'join/orientation/status';
  }
}

/**
 *  Wildcard loader function for hook_menu orientation id
 */
function psfc_orientation_orid_load($orid) {
  if (!is_numeric($orid)) {
    return FALSE;
  }
  $checked_orid = db_query("SELECT orid FROM {psfc_orientation_repeat_rules} WHERE orid = :orid", array(':orid' => $orid))->fetchField();
  if ($checked_orid == $orid) {
    return $orid;
  }
  return FALSE;
}

/**
 *  Wildcard loader function for hook_menu orientation blackout id
 *
 * @param $obid
 *   A black out date
 *
 * @return The blacked out data or FALSE
 */
function psfc_orientation_obid_load($obid) {
  if (!is_numeric($obid)) {
    return FALSE;
  }
  $checked_obid = db_query("SELECT obid FROM {psfc_orientation_blackout_days} WHERE obid = :obid", array(':obid' => $obid))->fetchField();
  if ($checked_obid == $obid) {
    return $obid;
  }
  return FALSE;
}

/**
 * Implements hook_entity_insert.
 *
 */
function psfc_orientation_entity_insert($entity, $type) {
  if($type == 'node' && $entity->type == 'orientation_attendee') {
    $node_wrapper = entity_metadata_wrapper('node', $entity);
    // Send out confirmation email.
    $params['node'] = $entity;
    global $language;
    $recipient = $node_wrapper->field_email->value();
    if(!empty($recipient)) {
      drupal_mail('psfc_orientation','registration_not_confirmed', $recipient, $language, $params);
      drupal_set_message(t('Confimration has been requested by email. Confirmation is required within 48 hours.'));
    }
    // Check remaining capacity and close if necessary.
    psfc_orientation_capacity($node_wrapper->field_orientation_nid->value(), TRUE);
  }
}

/**
 * Implements hook_entity_update.
 *
 * Ensure we update the orientation (close or re-open) depending on whether
 * this update cancels their registration.
 */
function psfc_orientation_entity_update($entity, $type) {
  if($type == 'node' && $entity->type == 'orientation_attendee') {
    $node_wrapper = entity_metadata_wrapper('node', $entity);
    // Check remaining capacity and close if necessary.
    psfc_orientation_capacity($node_wrapper->field_orientation_nid->value(), TRUE);
  }
}

/**
 * Implements hook_entity_delete.
 *
 */
function psfc_orientation_entity_delete($entity, $type) {
  if($type == 'node' && $entity->type == 'orientation_attendee') {
    $node_wrapper = entity_metadata_wrapper('node', $entity);
    $offset = 1;
    $orientation_node = $node_wrapper->field_orientation_nid->value();
    // If the orientation still exists, check remaining capacity and open if necessary.
    // (since a new spot is opening up).
    if($orientation_node) {
      psfc_orientation_capacity($orientation_node, TRUE, $offset);
    }
  }
  if ($type == 'node' && $entity->type == 'orientation') {
    // When deleting an orientation, delete all attendee nodes.
    $attendees = psfc_orientation_get_all_attendee_nodes($entity->nid);
    foreach ($attendees as $attendee) {
      // Warn the attendee that the orientation is cancelled.
      $node_wrapper = entity_metadata_wrapper('node', $attendee);
      $recipient = $node_wrapper->field_email->value();
      $account = $node_wrapper->author->value();
      if(empty($recipient)) {
        $recipient = $account->mail;
      }
      $params['node'] = $attendee;
      $params['node']->confirm = psfc_orientation_confirm_url($account, 'confirm', NULL, FALSE);
      $params['node']->cancel = psfc_orientation_confirm_url($account, 'cancel', NULL, FALSE);
      drupal_mail('psfc_orientation', 'registration_coop_cancelled', $recipient, language_default(), $params);

      // Delete the attendee node.
      node_delete($attendee->nid);
    }
  }
}

/**
 *  Helper function to return information about an orientation  rule
 *
 * @param $orid
 * Required. The unique id of the orientation repeat rule
 *
 * @return a keyed array with all relevant information about a rule.
 */
function psfc_orientation_get_repeat_rule_info($orid) {
  $result = db_query("SELECT * FROM {psfc_orientation_repeat_rules} WHERE orid = :orid", array(':orid' => $orid));
  return $result->fetchAssoc();
}

/**
 *  Helper function to determine next repeated orienation
 *
 */
function psfc_orientation_determine_next_repeat($time, $from) {
  $two_weeks = strtotime('+ 2 weeks', $from);
  $date = date('Y-m-d', $two_weeks);
  $string = $date . ' ' . $time['hour'] . ':' . $time['minute'] . ' ' . $time['ampm'];
  $next_orientation = strtotime($string);
  return $next_orientation;
}

/**
 * Helper function to split apart the time_of_day saved in orientation_rule
 */
function psfc_orientation_split_out_time_of_day($time_of_day) {
  $split0 = explode(':', $time_of_day);
  $split1 = explode(' ', $split0[1]);

  $time = array();
  $time['hour'] = $split0[0];
  $time['minute'] = $split1[0];
  $time['ampm'] = $split1[1];
  return $time;
}

/**
 * Wrapper for theme function to display user's orientation status page
 *
 */
function psfc_orientation_status() {
  return theme('psfc_orientation_status');
}

/**
 * Helper function to determine if there is already an orientation scheduled
 * for a time slot
 *
 * @param $time timestamp
 *
 * @return blooean TRUE if there there is an already scheduled orientation
 */
function psfc_orientation_orientation_exists($time) {
  //cleanup time for pdo
  $date = new DateTime("@$time");
  $time = $date->format("Y-m-d H:i:s");
  $sql = 'SELECT COUNT(*) AS count FROM {field_data_field_orientation_date} ort INNER JOIN {node} n ON ort.entity_id = n.nid AND ort.revision_id = n.vid WHERE n.status = 1 AND ort.field_orientation_date_value = :date';
  $query = db_query($sql, array(':date' => $time));
  if ($query->fetchField() > 0) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function to determine if a date is blacked out
 *
 * @param $date a datestring formatted as YYY-MM-DD
 *
 *
 * @return boolean TRUE if $date is blacked out
 */
function psfc_orientation_orientation_blacked_out($date) {
  $date = date("Y-m-d H:i:s", $date);
  $sql = 'SELECT blackout_date FROM {psfc_orientation_blackout_days} WHERE blackout_date = :blackout_date';
  $query = db_query($sql, array(':blackout_date' => $date));
  if ($query->fetchField() == $date) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Build an orientation node
 *
 * @param $orientation_rule an orientation rule as built by
 *    psfc_orientation_get_repeat_rule_info().
 *
 * @param $time_value the time of the desired orientation in the format:
 *    YYYY-MM-DDTHH:MM:SS
 *
 * @return the node object of the new orientation.
 */
function psfc_orientation_node_build($orientation_rule, $time_value) {
  // Create a wrapper
  $node = entity_create('node', array('type' => 'orientation'));

  $date_object = new DateTime("@$time_value");

  $node_wrapper = entity_metadata_wrapper('node', $node);
  // dpm($node_wrapper->getPropertyInfo());
  $node_wrapper->title->set(date('l, F j', $date_object->getTimestamp()));
  $node_wrapper->status->set(1);
  $node_wrapper->promote->set(0);
  $node_wrapper->sticky->set(0);
  $body = variable_get('psfc_orientation_default_description', t('PSFC Orientations are blah blah blah'));
  $node_wrapper->body->set(array('value' => $body, 'format' => 'psfc_html_filter'));
  $node_wrapper->field_orientation_capacity->set($orientation_rule['capacity']);
  $node_wrapper->field_orientation_date->set($date_object->getTimestamp());
  $node_wrapper->field_orientation_closed->set(0);
  $node_wrapper->field_orientation_reminder->set(0);

  $node_wrapper->save();
  return $node_wrapper;
}


/**
 * Build an attendee node from account
 *
 * @param $account the attendee user account
 *
 * @param $onid the node id for the orientation the attended will attend.
 * *
 * @return a node wrapper object for the new orientation attendee node.
 */
function psfc_orientation_node_build_attendee_from_account($account, $onid, $confirmed = 0) {
  // Create a wrapper for the given user
  $user_wrapper = entity_metadata_wrapper('user', $account);

  $first = $user_wrapper->field_fullname->field_firstname->value();
  $last = $user_wrapper->field_fullname->field_lastname->value();
  $email = $account->mail;
  $uid = $account->uid;
  $phone = NULL;

  return psfc_orientation_node_build_attendee($onid, $first, $last, $email, $phone, $uid, $confirmed);
}

/**
 * Build an attendee node from values.
 *
 * @param $first_name The attendees first name
 * @param $last_name The attendees last name
 * @param $email The attendees email
 * @param $phone The attendees phone number
 * @param $uid The uid of the owner
 *
 * @return a node wrapper object for the new orientation attendee node.
 */
function psfc_orientation_node_build_attendee($onid, $first_name, $last_name, $email = NULL, $phone = NULL, $uid = NULL, $confirmed = 0) {
  if(empty($uid)) {
    global $user;
    $uid = $user->uid;
  }

  // Create a wrapper for the attendee node
  $node = entity_create('node', array('type' => 'orientation_attendee'));

  $node_wrapper = entity_metadata_wrapper('node', $node);
  // dpm($node_wrapper->getPropertyInfo());

  $node_wrapper->title->set($first_name . " " . $last_name);
  $node_wrapper->status->set(1);
  $node_wrapper->promote->set(0);
  $node_wrapper->sticky->set(0);

  // Add the user account details to the node
  $node_wrapper->field_first_name->set($first_name);
  $node_wrapper->field_last_name->set($last_name);
  $node_wrapper->field_orientation_nid->set($onid);
  $node_wrapper->field_email->set($email);
  $node_wrapper->field_phone->set($phone);
  $node_wrapper->author->set($uid);
  $node_wrapper->field_confirmed_orientation->set($confirmed);
  $node_wrapper->save();
  return $node_wrapper;
}

/**
 * Helper function to count open slots in an orientation and close or reopen it.
 *
 * @param $node
 *   Either an orientation node object or node ID.
 * @param $close
 *   If TRUE the orientation node should be closed or opened.
 * @param $offset
 *   The number to modify the count by. When called by hook_entity_delete
 *   one must be added to the count to account for the registrant
 *   that is about to be deleted but has not yet been deleted.
 * @return The number of open spaces remaining for the orientation.
 */
function psfc_orientation_capacity($node, $close = FALSE, $offset = 0) {
  if (!is_object($node)) {
    // We have to reset the node cache to get the latest count.
    $node = node_load($node, NULL, TRUE);
  }
  $node_wrapper = entity_metadata_wrapper('node', $node);
  $capacity = $node_wrapper->field_orientation_capacity->value();

  // Get count of users on the system registered.
  $result = db_query("SELECT COUNT(*) FROM {field_data_field_orientation_nid} fnid JOIN {field_data_field_canceled_orientation} fcancel USING(entity_id) WHERE fnid.field_orientation_nid_nid = :nid AND fcancel.field_canceled_orientation_value != 1", array(':nid' => $node->nid));
  if ($result->rowCount() == 0) {
    $user_reg_count = 0;
  }
  else {
    $user_reg_count = $result->fetchField();
  }

  // Get count of remaining slots
  $count = $capacity - $user_reg_count + $offset;

  // It's full. Close it if it's not already closed.
  if ($close && $count <= 0 && $node_wrapper->field_orientation_closed->value() == 0) {
    $node_wrapper->field_orientation_closed->set(1); // 0 is open, 1 is closed.
    $node_wrapper->save();
  }

  // TODO: Change to reflect new open/ closed  field structure.
  // It's not full, reopen it if it's not already open.
  if ($close && $count > 0 && $node_wrapper->field_orientation_closed->value() == 1) {
    $date = $node_wrapper->field_orientation_date->value();
    $now = time();

    // Don't re-open a orientation less than 2 hours prior to it's start.
    $compare = $now + (60 * 60 * 2);
    if($compare < $date) {
      $node_wrapper->field_orientation_closed->set(0); // 0 is open, 1 is closed.
      $node_wrapper->save();
    }
  }
  return $count;
}

/**
 * Helper function to close past orientations. Called by cron.
 *
 */
function psfc_orientation_close_old() {
  $old = date('Y-m-d H:i:s', REQUEST_TIME - 3600);
  // TODO: Change to reflect new open/ closed  field structure.
  $sql = "SELECT n.nid FROM node n JOIN field_data_field_orientation_closed oc ON n.nid = oc.entity_id JOIN field_data_field_orientation_date od USING(entity_id) WHERE field_orientation_closed_value = 0 AND field_orientation_date_value < :time";
  $result = db_query($sql, array(':time' => $old));
  while ($nid = $result->fetchField()) {
    $node = node_load($nid);
    $node_wrapper = entity_metadata_wrapper('node', $node);
    $node_wrapper->field_orientation_closed->set(1);
    $node_wrapper->save();
  }
}

/**
 * Helper function to check if user is already signed up for an open orientation.
 *
 * @param $uid
 *   User's uid to check.
 *
 * @return Boolean.
 */
function psfc_orientation_registered($uid) {
  // TODO: Change to reflect new open/ closed  field structure.
  if (db_query("SELECT COUNT(*)
    FROM {field_data_field_orientation_nid} a
    JOIN {node} n
    ON a.entity_id = n.nid
    AND a.revision_id = n.vid
    JOIN {field_data_field_orientation_closed} o
    ON a.field_orientation_nid_nid = o.entity_id
    LEFT JOIN {field_data_field_canceled_orientation} c
    ON a.entity_id = c.entity_id
    WHERE o.field_orientation_closed_value = 0 
    AND c.field_canceled_orientation_value != 1
    AND n.uid = :userid_uid",
  array(':userid_uid' => $uid))->fetchField()) {
    return TRUE;
  }
  return FALSE;
}
/**
 * Helper function to check if user is already signed up for a particular
 *  orientation
 *
 * @param $uid
 *   User's uid to check.
 * @param $nid
 *   Orientation nid to check.
 *
 * @return Boolean.
 */
function psfc_orientation_registered_specific($uid, $nid) {
  if (db_query("SELECT COUNT(*) FROM {content_type_orientation_attendee} WHERE field_orientation_nid_nid = :field_orientation_nid_nid AND field_userid_uid = :field_userid_uid", array(':field_orientation_nid_nid' => $nid, ':field_userid_uid' => $uid))->fetchField()) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function to create a signup link for an orientation.
 *
 * @param $nid
 *   The nid of the orientation node.
 *
 * @return A link starting the signup process or a link to the login/register page.
 */
function psfc_orientation_signup_link($nid) {
  global $user;
  // Return link to the orientation.
  if ($user->uid > 0) {
    // TODO Convert "user_load" to "user_load_multiple" if "$user->uid" is other than a uid.
    // To return a single user object, wrap "user_load_multiple" with "array_shift" or equivalent.
    // Example: array_shift(user_load_multiple(array(), $user->uid))
    $account = user_load($user->uid);
    $member_status = $account->member_status;
    if (psfc_orientation_registered_specific($account->uid, $nid)) {
      return '<div class="button-rounded"><span>' . l(t("Orientation Status"), 'join/orientation/status') . '</span></div>';
    }
    elseif ($member_status['orientation']['registered']) {
      return;
    }
    else {
      return '<div class="button-rounded"><span>' . l(t('I want this one'), 'join/orientation/signup/session/' . $nid) . '</span></div>';
    }
  }
  return '<div class="button-rounded"><span>' . l(t('Log in to select'), 'login') . '</span></div>';
}


/**
 * Callback function for the signup link.
 *
 * Write the registration to the db (add attendee node).
 *
 * @param $nid
 *   The nid of the orientation node.
 *
 */
function psfc_orientation_signup_session_register($onid) {
  global $user;
  // Is user already signed up?
  if (psfc_orientation_registered($user->uid) ) {
    drupal_goto('join/orientation/status');
  }
  // Create the attendee node for the logged in user, if not already registered
  // and there is space.
  if (psfc_orientation_capacity($onid, TRUE) >= 1) {
    psfc_orientation_node_build_attendee_from_account($user, $onid);
  }

  // No more spots open for logged in user!
  else {
    drupal_goto('node/' . variable_get('psfc_orientation_orientation_filled', ''));
  }

  // Logged in user is registered.
  drupal_goto('node/' . variable_get('psfc_orientation_confirm_orientation_page', ''));
}

/**
 * Menu callback for attendee confirm and cancel link.
 *
 * @param $uid
 *   Attendee's uid.
 * @param $timestamp
 *   Unix time when link was created.
 * @param $hassed_pass
 *   md5 hash of the attendee's password.
 * @param $action
 *   Confirm or cancel the orientation registration.
 *
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function psfc_orientation_confirm($uid, $timestamp, $hashed_pass, $action) {
  // Check for active user and confirm hashed pass.
  $account = user_load($uid);
  if (is_numeric($uid) && $account) {
    if ($hashed_pass == psfc_orientation_confirm_rehash($account->pass, $timestamp, $account->login)) {
      // Load the attendee node.
      if ($node = psfc_orientation_get_attendee_node($account)) {
        if ($action == 'confirm') {
          $node_wrapper = entity_metadata_wrapper('node', $node);
          $node_wrapper->field_confirmed_orientation->set(1);
          $node_wrapper->save();
          drupal_set_message("You have been confirmed!");
          drupal_goto('<front>');
        }
        elseif ($action == 'cancel') {
          // show confirm form.
          return drupal_get_form('psfc_orientation_cancel_confirm', $node);
        }
      }
      // Account exists, but no attendee node. This should probably be a page
      // redirect and not a message.
      else {
        drupal_goto('<front>');
      }
    }
  }
  //No account or bad link. An attendee will get here if trying to confirm too
  // late. This should probably be a page redirect and not a message.
  drupal_set_message(t('There is no user for the operation you requested.'));
  drupal_goto('join/orientation');
}

/**
 * Confirm registration cancellation.
 */
function psfc_orientation_cancel_confirm($form, $form_state, $node) {
  $node_wrapper = entity_metadata_wrapper('node', $node);
  $form['#orientation_attendee_uid'] = $node_wrapper->author->value()->uid;
  $form['#orientation_attendee_nid'] = $node_wrapper->getIdentifier();
  $question = t('Confirm Your Cancellation');
  $path = '<front>';
  $description = 'Are you sure you want to cancel your registration for new member orientation?<br /><br />';
  $yes = t('Yes, I Want to Cancel My Registration');
  $no = t('No, Please Do Not Cancel');
  return confirm_form($form, $question, $path, $description, $yes, $no, $name = 'confirm_cancellation');
}

/**
 * Confirm registration cancellation form submit.
 */
function psfc_orientation_cancel_confirm_submit($form, $form_state) {
  psfc_orientation_cancel_registration($form['#orientation_attendee_nid']);
  drupal_goto('<front>');
}

/**
 * Cancel orientation
 */
function psfc_orientation_cancel_registration($nid) {
  $node = node_load($nid);
  $node_wrapper = entity_metadata_wrapper('node', $node);
  $node_wrapper->field_canceled_orientation->set(1);
  $node_wrapper->save();
  $orientation_nid = $node_wrapper->field_orientation_nid->value()->nid;
  $close_or_reopen = TRUE;
  psfc_orientation_capacity($orientation_nid, $close_or_reopen);

  drupal_set_message(t("Your registration has been cancelled."));
}

/**
 * Generate a secure confirm/cancel link.
 *
 * @param $account
 *   Attendee's useraccount.
 * @param $action
 *   Confirm or cancel the orientation registration.
 *
 * @return An absolute link.
 */
function psfc_orientation_confirm_url($account, $action, $text = 'Click here to @action your orientation.', $l = TRUE) {
  $timestamp = REQUEST_TIME;
  if ($l) {
    return l(t($text, array('@action' => $action)), 'join/orientation/confirm/' . $account->uid . '/' . $timestamp . '/' . psfc_orientation_confirm_rehash($account->pass, $timestamp, $account->login) . '/' . $action, array('absolute' => TRUE));
  }
  // Used to format link for email tokens.
  else {
    return url('join/orientation/confirm/' . $account->uid . '/' . $timestamp . '/' . psfc_orientation_confirm_rehash($account->pass, $timestamp, $account->login) . '/' . $action, array('absolute' => TRUE));
  }
}

/**
 * Generate a hashed password.
 *
 * @param $password
 *   Attendee's password.
 * @param $timestamp
 *   Unix time of registration.
 * @param $login
 *   Unix time of attendee's first login. This was automatically set on reg.
 *
 * @return A hashed password.
 */
function psfc_orientation_confirm_rehash($password, $timestamp, $login) {
  return md5($timestamp . $password . $login);
}

/**
 * Helper function to load single attendee node.
 *
 * @param $account
 *   The attende.
 *
 * @return Node object.
 */
function psfc_orientation_get_attendee_node($account) {
  $sql = "SELECT nid FROM {node} n 
    LEFT JOIN {field_data_field_canceled_orientation} canceled 
    ON n.nid = canceled.entity_id WHERE type = 'orientation_attendee' AND 
    uid = :uid AND
    canceled.field_canceled_orientation_value != 1
    ORDER BY created DESC LIMIT 1";
  $result = db_query($sql, array(':uid' => $account->uid));
  if ($result->rowCount() > 0) {
    while ($nid = $result->fetchField()) {
      $node = (is_numeric($nid)) ? node_load($nid) : FALSE;
      return $node;
    }
  }
  return FALSE;
}

/**
 * Helper function to determine if user has any up-coming orientations.
 *
 * @param $account
 *   The attende.
 *
 * @return boolean 
 */
function psfc_orientation_user_has_upcoming_orientation($account) {
  $sql = "SELECT n.nid AS count FROM {node} n JOIN {field_data_field_orientation_nid} o 
    ON n.nid = o.entity_id JOIN {field_data_field_orientation_date} d 
    ON o.field_orientation_nid_nid = d.entity_id WHERE uid = :uid AND 
    field_orientation_date_value > :date";

  $result = db_query($sql, array(':uid' => $account->uid, ':date' => date('Y-m-d H:i:s')));
  if ($result->rowCount() > 0) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Get list of attendees for given orientation nid
 *
 * @param $oid
 *   The nid of the orientation node
 * @return
 *   An array of attendee node objects.
 */
function psfc_orientation_get_all_attendee_nodes($oid) {
  $attendees = array();

  $result = db_query("SELECT field_data_field_orientation_nid.entity_id FROM
    field_data_field_confirmed_orientation 
    JOIN field_data_field_orientation_nid USING(entity_id)
    JOIN field_data_field_canceled_orientation USING(entity_id)
    WHERE field_confirmed_orientation_value = 1 AND
    field_canceled_orientation_value != 1 AND
    field_orientation_nid_nid = :nid", array(':nid' => $oid));

  while ($nid = $result->fetchField()) {
    $attendees[] = node_load($nid);
  }
  return $attendees;
}

/**
 * Theme a table with 1 orientation date.
 * *
 * @param $orientation
 *   The orientation node.
 */
function theme_psfc_orientation_date_table($variables) {
  $date = $variables['date'];
  $headers = array('Date', 'Day', 'Time', '');
  $rows[0] = array(
    array(
      'data' => '<span class = "mon">' . format_date($date, 'custom', 'M') . '</span>' . ' <span class = "date">' . format_date($date, 'custom', 'j') . '</span>',
      'class' => 'first',
    ),
    array(
      'data' => '<span class = "day">' . format_date($date, 'custom', 'l') . '</span>',
    ),
    array(
      'data' => '<span class = "time">' . format_date($date, 'custom', 'g:i') . '</span>' . '<span class = "meridiem">' . format_date($date, 'custom', 'A') . '</span>',
    ),
  );

  // Move the register me to the table if we're on the correct page.
  if (arg(1) == 'orientation' && arg(2) == 'signup') {
    $rows[0][] = array(
      'data' => '<div class="button-rounded"><span>' .  l(t('Yes, Register Me'), 'join/orientation/signup/session/register/' . $orientation->nid) . '</span></div>',
      'class' => 'last',
    );

  }
  // Set runtime back to America/New_York.
  return theme('table', array('header' => $headers, 'rows' => $rows, 'attributes' => array('class' => array('odate-table'))));
}
/**
 * Theme a the user's orientation status page.
 *
 */
function theme_psfc_orientation_status() {
  global $user;
  if (!$user->uid) {
    return t('Please login to the site to check you registration status.');
  }

  if (!$attendee = psfc_orientation_get_attendee_node($user)) {
    $nid = variable_get('psfc_orientation_register', NULL);
    if(is_null($nid)) {
      drupal_message("Sorry! We hit a big when trying to show you the reigstration page.");
      drupal_goto('<front>');
      exit;
    }
    $text = t('You have created a user account, but are not registered for any upcoming Orientations.');
    $link_text = t("Register for Orientation");
    $link = l($link_text, "node/$nid");
    return $text . '<br /><br /><div class="button-rounded"><span>' . $link . '</span></div>';
  }
  $attendee_node_wrapper = entity_metadata_wrapper('node', $attendee);
  $nid = $attendee_node_wrapper->field_orientation_nid->value()->nid;
  $orientation = node_load($nid);

  $output = '<div class="status-info-text">';
  $output .= '<p>' . t('You have signed up for the following Orientation Session:') . '</p>';
  $output .= '</div>';

  $output .= '<div class="status-info-date">';
  $orientation_node_wrapper = entity_metadata_wrapper('node', $orientation);
  $date = $orientation_node_wrapper->field_orientation_date->value();
  $table = array('date' => $date);
  $output .= theme('psfc_orientation_date_table', $table);
  $output .= '</div>';
  if (!$attendee_node_wrapper->field_confirmed_orientation->value()) {
    $output .= '<p>' . t('You are not yet confirmed. You should have received an email with confirmation instructions. You must confirm within 48 hours of registering or you will lose your reserved place.') . '</p>';
  }
  else {
    $output .= '<p>' . t('Your orientation registration is confirmed. ') . '</p>';
  }
  $output .= '<p>' . t('If this is not correct, please cancel and sign up again.');
  $output .= '<div class="button-rounded"><span>' . psfc_orientation_confirm_url($user, 'cancel', 'Cancel Registration') . '</span></div>';
  return $output;
}

/**
 * Helper function to delete past blackout days via cron
 */
function psfc_orientation_past_blackout_delete() {
  $q = db_query("SELECT * FROM {psfc_orientation_blackout_days}");

  $obids = array();
  while ($r = $q->fetchAssoc()) {
    $date = strtotime($r['blackout_date']);
    if ($date < REQUEST_TIME) {
      $obids[] = $r['obid'];
    }
  }
  foreach ($obids as $key => $obid) {
    db_delete('psfc_orientation_blackout_days')
      ->condition('obid', $obid)
      ->execute();
  }
}

/**
 * Helper function to pass a user's orientation status to
 * the member_data module
 *
 * @param $uid The user id for the the member status you are looking for
 *
 * @return A numeric representation of the user/member's orientation status,
 *  0: User has attended a registration
 *  1: User has select and confirmed a registration slot
 *  2: User has selected but not confirmed
 *  3: User has neither selected, confirmed, or completed reg
 */
function psfc_orientation_user_orientation_status($uid) {
  // TODO Convert "user_load" to "user_load_multiple" if "$uid" is other than a uid.
  // To return a single user object, wrap "user_load_multiple" with "array_shift" or equivalent.
  // Example: array_shift(user_load_multiple(array(), $uid))
  $user = user_load($uid);
  $member_status = $user->member_status;
  if (!$member_status['orientation']['registered']) {
    return 3;
  }
  elseif ($member_status['orientation']['confirmed'] == 0) {
    return 2;
  }
  elseif ($member_status['orientation']['confirmed'] == 1    && !$member_status['orientation']['attended']) {
    return 1;
  }
  elseif ($member_status['orientation']['attended'] == 1) {
    return 0;
  }
}

/**
 * Helper function returns number of future orientations that have openings.
 *
 **/
function psfc_orientation_check_openings() {
  $sql = "SELECT count(nid) FROM {node} n JOIN {field_data_field_orientation_closed} c ON " .
    "n.nid = c.entity_id WHERE c.entity_type = 'node' AND c.bundle = 'orientation' AND ".
    "(field_orientation_closed_value = 0 OR field_orientation_closed_value IS NULL) AND ".
    "n.status = 1";
  $result = db_query($sql);
  return $result->fetchField();
}

/*
 * Theme function to return orientation status/workflow breadcrumbs.
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_psfc_orientation_crumbs($variables) {
  $path = $variables['path'];

  // Trim unneeded path elements.
  $path = explode('/', $path);
  $path = array_slice($path, 0, 4);
  $path = implode('/', $path);

  if (!in_array($path, array('join/orientation', 'join/orientation/status', 'node/40', 'join/orientation/signup/session', 'node/43'))) {
    return;
  }

  global $user;
  $status = psfc_orientation_user_orientation_status($user->uid);

  $items = array(
    array(
      'data' => 'Select',
    ),
    array(
      'data' => 'Review',
    ),
    array(
      'data' => 'Confirm',
    ),
    array(
      'data' => 'You are Confirmed',
    ),
  );
  if ($path == 'join/orientation/signup/session') {
    $items[1]['class'] = $status == 1 ? '' : 'active';
  }
  else {
    switch ($status) {
      case 1:
        $items[3]['class'] = 'active';
        break;
      case 2:
        $items[2]['class'] = 'active';
        break;
      case 3:
        $items[0]['class'] = 'active';
        break;
    }
    switch ($path) {
      case 'join/orientation/signup/session':
        $items[1]['class'] = $status == 1 ? '' : 'active';
        break;
    }
  }
  return theme('item_list', array('items' => $items, 'title' => NULL, 'type' => 'ul', 'attributes' => array('id' => 'breadcrumbs')));
}

/*
 * Implements hook_node_operations().
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function psfc_orientation_node_operations() {
  $operations = array(
    'confirm_attendee' => array(
      'label' => t('Confirm attendees'),
      'callback' => 'psfc_orientation_mass_attendee_helper',
      'callback arguments' => array('confirmed' => array('field_attendee_confirmed' => 1)),
    ),
    'unconfirm_attendee' => array(
      'label' => t('Unconfirm attendees'),
      'callback' => 'psfc_orientation_mass_attendee_helper',
      'callback arguments' => array('unconfirmed' => array('field_attendee_confirmed' => 0)),
    ),
  );
  return $operations;
}

/*
 * Mass operations on attendees. Used by VBO.
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function psfc_orientation_mass_attendee_helper($nodes, $context) {
  foreach ($nodes as $nid) {
    $node = node_load($nid);
    if ($node->type == 'orientation_attendee') {
      foreach ($context as $field => $value) {
        $node->{$field}[0]['value'] = $value;
        node_save($node);
        switch ($value) {
          case 0:
            drupal_set_message(t('%name has been unconfirmed to attend.', array('%name' => $node->title)));
            break;
          case 1:
            drupal_set_message(t('%name has been confirmed to attend.', array('%name' => $node->title)));
            break;
        }
      }
    }
  }
}

/**
 * Implementation of hook_node_view_alter
 **/
function psfc_orientation_node_view_alter(&$build) {
  $build['#post_render'][] = 'psfc_orientation_node_post_render';
}


/**
 * Implementation of hook_node_access
 *
 * The orientation_attendee contains sensitive information, so hide it
 * from anonymous users and registered users that are not this attendee.
 *
 **/
function psfc_orientation_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;
  if ($type == 'orientation_attendee') {
    $owner_uid = NULL;
    if (!is_string($node)) {
      // I'm not sure under what condition $node would be a string, but
      // following example on:
      // https://api.drupal.org/api/drupal/modules%21node%21node.api.php/function/hook_node_access/7.x
      $owner_uid = $node->uid;
    }

    if (empty($account->uid)) {
      // Anonymous users get no access to attendee nodes.
      return NODE_ACCESS_DENY;
    }
    if (!user_access('edit any orientation_attendee content', $account)) {
      // Ability to edit orientation attendees is a proxy for someone who
      // should also be able to view it. If you don't have this permission,
      // then you can only view this record if you are the owner.
      if ($owner_uid != $account->uid) {
        return NODE_ACCESS_DENY;
      }
    }
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Convert any of our tokens in the node
 *
 **/
function psfc_orientation_node_post_render($markup, $element) {
  return token_replace($markup);
}

/**
 * Display page of upcoming orientations. Menu Call back.
 **/
function psfc_orientation_join_orientation() {
  // Check to see if they have already registered for an orientation
  global $user;
  if (!$attendee = psfc_orientation_get_attendee_node($user)) {
    $display_id = 'default';
    $view_name = 'orientations';
    $views = views_embed_view($view_name, $display_id);
    if(trim(strip_tags($views)) == '') {
      drupal_goto('content/sorry-there-are-no-orientation-sessions-available-time');
    }
    return $views;
  }
  else {
    return psfc_orientation_status();
  }
}

/**
 * Computed field used in orientation view.
 */
function computed_field_field_confirmed_attendees_compute(&$entity_field, $entity_type, $entity, $field, $instance, $langcode, $items) {
  $sql = "SELECT COUNT(*) FROM field_data_field_confirmed_orientation 
    JOIN field_data_field_orientation_nid USING(entity_id)
    JOIN field_data_field_canceled_orientation USING(entity_id)
    WHERE field_confirmed_orientation_value = 1 AND
    field_canceled_orientation_value != 1 AND
    field_orientation_nid_nid = :nid";

  $result = db_query($sql, array(':nid' => $entity->nid));
  $count = $result->fetchField();
  $entity_field[0]['value'] = intval($count);

}
