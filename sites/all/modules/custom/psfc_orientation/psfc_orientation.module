<?php
/**
 * @file PSFC Orientation module
 */

module_load_include('inc', 'psfc_orientation', 'psfc_orientation.email');
module_load_include('inc', 'psfc_orientation', 'psfc_orientation.nodemap');
module_load_include('inc', 'psfc_orientation', 'psfc_orientation.token');


/**
 * Implements hook_permission().
 */
function psfc_orientation_permission() {
  return array(
    'administer psfc orientation' => array(
      'title' => t('administer psfc orientation'),
      'description' => t('Allow user to administer all orientation module settings'),
    ),
    'administer orientation attendance' => array(
      'title' => t('administer orientation attendance'),
      'description' => t('Allow user to change attendance at orientations.'),
    ),
    'sign up for psfc orientation' => array(
      'title' => t('sign up for psfc orientation'),
      'description' => t('Allow a user to sign up for Orientation.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function psfc_orientation_menu() {
  $items = array();

  // this should probably live in a generic helper module.
  // it lives here because this module got here first --nat
  $items['admin/psfc'] = array(
    'title' => 'PSFC Admin Page',
    'description' => 'An Admin landing page for psfc pages',
    'access callback' => 'psfc_orientation_access_admin',
    'page callback' => 'psfc_orientation_temp_admin_land',
  );
  $items['admin/psfc/orientation'] = array(
    'title' => 'Orientation',
    'description' => 'Allow coop workers to change orientation settings.',
    'page callback' => 'psfc_orientation_admin_page',
    'access callback' => 'psfc_orientation_access_admin',
    'file' => 'psfc_orientation.admin.inc',
    'weight' => 10,
  );
  $items['admin/psfc/orientation/overview'] = array(
    'title' => 'Orientation Overview',
    'description' => 'Allow coop workers to change orientation settings.',
    'page callback' => 'psfc_orientation_admin_page',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/add-rule'] = array(
    'title' => 'Create Orientation Rule',
    'description' => 'Create a new orientation rule.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_admin_add_rule'),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'psfc_orientation.admin.inc',
    'weight' => 8,
  );
  $items['admin/psfc/orientation/delete-rule/%psfc_orientation_orid'] = array(
    'title' => 'Delete Orientation Rule',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_admin_delete_rule', 4),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_CALLBACK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/edit-rule/%psfc_orientation_orid'] = array(
    'title' => 'Edit Orientation Rule',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_admin_edit_rule', 4),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_CALLBACK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/add-blackout'] = array(
    'title' => 'Create a Blackout date',
    'description' => 'Orientations will not be automatically created on this date.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_add_blackout'),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'psfc_orientation.admin.inc',
    'weight' => 10,
  );
  $items['admin/psfc/orientation/delete-blackout/%psfc_orientation_obid'] = array(
    'title' => 'Delete a Blackout Date',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_delete_blackout', 4),
    'access arguments' => array('administer psfc orientation'),
    'type' => MENU_CALLBACK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/add-registrant'] = array(
    'title' => 'Manual sign up',
    'description' => 'Admin users can sign up someone who does not have internet access',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_add_registrant'),
    'access callback' => 'psfc_orientation_access_admin',
    'type' => MENU_LOCAL_TASK,
    'file' => 'psfc_orientation.admin.inc',
    'weight' => 11,
  );
  $items['admin/psfc/orientation/psfc-orientation-autocomplete'] = array(
    'title' => 'User email autocomplete',
    'page callback' => 'psfc_orientation_email_autocomplete',
    'access callback' => 'user_access',
    'access callback' => 'psfc_orientation_access_admin',
    'type' => MENU_CALLBACK,
    'file' => 'psfc_orientation.admin.inc',
  );
  $items['admin/psfc/orientation/mail'] = array(
    'title' => 'Edit orientation emails',
    'description' => 'Configure default e-mail text for orientation messages.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_mail_settings'),
    'access arguments' => array('administer psfc orientation'),
    'file' => 'psfc_orientation.email.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 12,
  );
  $items['admin/psfc/orientation/nodemap'] = array(
    'title' => 'Map content pieces',
    'description' => 'Change where various pieces of Orientation content come from.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('psfc_orientation_nodemap_settings'),
    'access arguments' => array('administer psfc orientation'),
    'file' => 'psfc_orientation.nodemap.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 13,
  );

  $items['join/orientation/signup/session/%'] = array(
    'title' => 'Review your selection',
    'description' => 'Let the user check the date',
    'access arguments' => array('access content'),
    'page callback' => 'psfc_orientation_signup_session',
    'page arguments' => array(4),
    'type' => MENU_CALLBACK,
  );
  $items['join/orientation/signup/session/register/%'] = array(
    'title' => 'Do the registration',
    'access arguments' => array('access content'),
    'page callback' => 'psfc_orientation_signup_session_register',
    'page arguments' => array(5),
    'type' => MENU_CALLBACK,
  );
  $items['login'] = array(
    'title' => 'Sign in',
    'description' => 'Log in or create an account.',
    'page callback' => 'psfc_orientation_login',
    'access arguments' => array('access content'),
    'file' => 'psfc_orientation.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['join/orientation'] = array(
    'title' => 'Join an orientation',
    'description' => 'Register for an orientation.',
    'page callback' => 'psfc_orientation_join_orientation',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['join/orientation/status'] = array(
    'title' => 'Your Orientation Status',
    'description' => 'Are you signed up for orientation.',
    'page callback' => 'psfc_orientation_status',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['join/orientation/confirm/%/%/%/%'] = array(
    'title' => 'Set registration status',
    'page callback' => 'psfc_orientation_confirm',
    'page arguments' => array(3, 4, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_block_info().
 **/
function psfc_orientation_block_info() {
  $items = array(
    'login_or_create_account' => array(
      'info' => t("Login or Create an Account"),
     ),
  );
  return $items;
}

/**
 * Implements hook_block_info().
 **/
function psfc_orientation_block_view($delta = '') {
  switch($delta) {
    case "login_or_create_account":
      global $user;
      if(empty($user->uid)) {
        $text = t("Login or Create an Account");
        return array(
          'subject' => '',
          'content' => l($text, 'login')
        );
      }
      break;
  }
}

/**
 * User access function for admin pages intended for multiple roles.
 */
function psfc_orientation_access_admin() {
  if (user_access('administer orientation attendance')) {
    return TRUE;
  }
  elseif (user_access('administer psfc orientation')) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_theme().
 */
function psfc_orientation_theme() {
  return array(
    'psfc_orientation_login' => array(
      'variables' => array(),
    ),
    'psfc_orientation_date_table' => array(
      'variables' => array('date' => NULL),
    ),
    'psfc_orientation_status' => array(
      'variables' => array(),
    ),
    'psfc_orientation_crumbs' => array(
      'variables' => array('path' => NULL),
    ),
  );
}

/**
 * Implemetation of hook_cron().
 */
function psfc_orientation_cron() {
  // Create orientation based on repeat rules.
  $query = db_query("SELECT * FROM {psfc_orientation_repeat_rules}");
  while ($result = $query->fetchAssoc()) {
    if ($result['day_of_week'] == date('l')) {
      $time = psfc_orientation_split_time_of_day($result['orid']);
      $next_ort = psfc_orientation_determine_next_repeat($time);
      if (!psfc_orientation_orientation_exists($next_ort) && !psfc_orientation_orientation_blacked_out($next_ort) &&  psfc_orientation_orientation_creation_window($next_ort, 15)) {
        $node_wrapper = psfc_orientation_node_build($result, $next_ort);
        if ($node_wrapper->nid->value()) {
          watchdog('psfc_orientation', 'Added an orientation for: @date', array('@date' => $time_value), WATCHDOG_NOTICE);
        }
      }
    }
  }

  // Delete unconfirmed registrations after 48 hours. 
  $expires = REQUEST_TIME - (2 * 24 * 60 * 60);
  $sql = "SELECT n.nid AS attendee_nid, u.field_user_id_uid AS uid, ".
    "o.field_orientation_nid_nid AS orientation_nid ".
    "FROM {node} n JOIN {field_data_field_orientation_nid} o " .
    "ON n.nid = o.entity_id AND n.vid = o.revision_id JOIN ".
    "{field_data_field_confirmed_orientation} con ".
    "ON n.nid = con.entity_id AND n.vid = con.revision_id JOIN ".
    "{field_data_field_user_id} u ".
    "ON n.nid = u.entity_id AND n.vid = u.revision_id ".
    "WHERE n.type = 'orientation_attendee' AND ".
    "n.created < :created AND con.field_confirmed_orientation_value = 0";
  $result = db_query($sql, array(':created' => $expires));
  while ($attendee = $result->fetchAssoc()) {
    $account = user_load($attendee['uid'], TRUE);
    $account_wrapper = entity_metadata_wrapper('user', $account);
    // Make sure the account still exists.
    if (is_object($account)) {
      // Record non-confirmation in orientation node.
      $orientation_node = node_load($attendee['orientation_nid']);
      $orientation_wrapper = entity_metadata_wrapper('node', $orientation_node); 

      $attendee_node = node_load($attendee['attendee_nid']);
      $attendee_wrapper = entity_metadata_wrapper('node', $attendee_node);

      // Merge the existing unconfirmed field with the new value to reflect this deleted
      // user.
      $existing_message = $orientation_wrapper->field_orientation_unconfirmed->value();
      $cur_message = array($account_wrapper->field_fullname->field_firstname->value() . ' ' . 
        $account_wrapper->field_fullname->field_lastname->value() . ', ' . 
        $account->mail . ', Username: ' . $account->name . ', Date removed: ' . 
        format_date(REQUEST_TIME, 'long'));
      $delete_message = array_merge($existing_message, $cur_message);
      $orientation_wrapper->field_orientation_unconfirmed->set($delete_message);

      // Send missed confirmation window mail.
      $recipient = $account->mail;
      $params['node'] = $attendee_node;
      drupal_mail('psfc_orientation', 'confirmation_window_missed', $recipient, language_default(), $params);

      //  Delete attendee node and update orientation node.
      node_delete($attendee['attendee_nid']);
      $orientation_wrapper->save();
    }
  }
  // Close old orientations.
  psfc_orientation_close_old();

  // Send reminder emails
  // psfc_orientation_send_reminders();

  // Delete old blackout dates
  psfc_orientation_past_blackout_delete();
}

/**
 * Implements hook_user_load().
 */
function psfc_orientation_user_load($users) {
  foreach ($users as $uid => $account) {
    // Add member statuses to the user object.
    if ($attendee = psfc_orientation_get_attendee_node($account)) {
      $users[$uid]->member_status['orientation']['registered'] = TRUE;
      $users[$uid]->member_status['orientation']['confirmed'] = $attendee->field_confirmed_orientation['und'][0]['value'];
      $users[$uid]->member_status['orientation']['attended'] = $attendee->field_attended_orientation['und'][0]['value'];
    }
    else {
      $users[$uid]->member_status['orientation']['registered'] = FALSE;
    }
  }
}

/**
 * Implements hook_user_cancel().
 */
function psfc_orientation_user_cancel($edit, $account, $method) {
  // When users are deleted, we delete their attendee nodes if they have any.
  $result = db_query("SELECT nid from {content_type_orientation_attendee} WHERE field_userid_uid = :field_userid_uid", array(':field_userid_uid' => $account->uid));
  while ($nid = $result->fetchField()) {
    node_delete($nid);
  }
}

/**
 * Implements hook_user_login().
 */
function psfc_orientation_user_login(&$edit, $account) {
  $ort_status = psfc_orientation_user_orientation_status($account->uid);
  if ($ort_status > 0) {
    drupal_goto('join/orientation/status');
  }
}

/**
 * Implements hook_form_alter().
 */
function psfc_orientation_form_alter(&$form, &$form_state, $form_id) {
  if ($form['#theme'] == 'confirm_form') {
    $form['actions']['cancel']['#prefix'] = '<div class="button-rounded red"><span>';
    $form['actions']['cancel']['#suffix'] = '</span></div>';
  }
  switch ($form_id) {
    case 'user_login':
      $form['submit']['#value'] = 'Sign In'; // Change button value.
      foreach (element_children($form) as $field) {
        unset($form[$field]['#description']);
      }
      break;
    case 'user_register_form':
      // Only alter reg form on our custom signup page.
      if ($_GET['q'] == 'login') {
        $form['actions']['submit']['#value'] = t('Sign Up'); // Change button value.
      }

      break;
    case 'views_bulk_operations_form__1':
      // string replacements to make the attendee manage page more friendly.
      $form['select']['operation']['#options']['views_bulk_operations_delete_node_action'] = t('Remove Attendee(s)');
      $form['select']['operation']['#options']['views_bulk_operations_fields_action'] = t('Record if Attendee(s) attended');
      $form['select']['operation']['#options']['system_send_email_action'] = t('Send Attendee(s) Email');
      if ($form['step']['#value'] == 1) {
        unset($form['select']['#title']);
      }
      if ($form['step']['#value'] == 3 && $form_state['storage'][1]['operation'] == 'views_bulk_operations_delete_node_action') {
        drupal_set_title(t('Are you sure you want to remove selected attendees?'));
        $p = $form['description']['#value'];
        $pattern = '/<h3\b[^>]*>(.*?)<\/h3>/ims';
        $content = '<h2>' . t('You have selected the following attendees for removal from their orientation:') . '</h2>';
        $content .= '<div><em>' . t('NOTE: This action cannot be undone, the user will need to be signed up again.') . '</em><br /><br /></div>';
        $form['description']['#value'] = preg_replace($pattern, $content, $p);
      }
      if ($form['step']['#value'] == 3 && $form_state['storage'][1]['operation'] == 'system_send_email_action') {
        drupal_set_title(t('Are you sure you want to email these attendees?'));
        $p = $form['description']['#value'];
        $pattern = '/<h3\b[^>]*>(.*?)<\/h3>/ims';
        $content = '<h2>' . t('You have selected the following attendees to receive your email:') . '</h2>';
        $content .= '<div><em>' . t('NOTE: The email will be sent immediately when you click confirm.') . '</em><br /><br /></div>';
        $form['description']['#value'] = preg_replace($pattern, $content, $p);
      }
      if ($form['step']['#value'] == 3 && $form_state['storage'][1]['operation'] == 'views_bulk_operations_fields_action') {
        drupal_set_title(t('Are you sure you want to update the attendance status?'));
      }
      if ($form['step']['#value'] == 2 && $form['operation']['#value']['key'] == 'system_send_email_action') {
        drupal_set_title(t('Send Orientation Attendees an Email'));
      }
      break;
  }
}

/**
 * Implements hook_views_api().
 */
function psfc_orientation_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'psfc_orientation'),
    //'path' => drupal_get_path('module', 'psfc_orientation') . '/includes',
  );
}

/**
 *  Wildcard loader function for hook_menu orientation id
 */
function psfc_orientation_orid_load($orid) {
  if (!is_numeric($orid)) {
    return FALSE;
  }
  $checked_orid = db_query("SELECT orid FROM {psfc_orientation_repeat_rules} WHERE orid = :orid", array(':orid' => $orid))->fetchField();
  if ($checked_orid == $orid) {
    return $orid;
  }
  return FALSE;
}

/**
 *  Wildcard loader function for hook_menu orientation blackout id
 *
 * @param $obid
 *   A black out date
 *
 * @return The blacked out data or FALSE
 */
function psfc_orientation_obid_load($obid) {
  if (!is_numeric($obid)) {
    return FALSE;
  }
  $checked_obid = db_query("SELECT obid FROM {psfc_orientation_blackout_days} WHERE obid = :obid", array(':obid' => $obid))->fetchField();
  if ($checked_obid == $obid) {
    return $obid;
  }
  return FALSE;
}

/**
 * Implements hook_entity_insert.
 *
 */
function psfc_orientation_entity_insert($entity, $type) {
  if($type == 'node' && $entity->type == 'orientation_attendee') {
    $node_wrapper = entity_metadata_wrapper('node', $entity); 
    // Send out confirmation email.
    $params['node'] = $entity;
    global $language;
    $recipient = $node_wrapper->field_email->value();
    $account = $node_wrapper->field_user_id->value();
    if(empty($recipient)) {
      $recipient = $account->mail;
    }
    drupal_mail('psfc_orientation','registration_not_confirmed', $recipient, $language, $params);
    drupal_set_message(t('Confimration has been requested by email. Confirmation is required within 48 hours.'));
    // Check remaining capacity and close if necessary.
    psfc_orientation_capacity($node_wrapper->field_orientation_nid->value(), TRUE);
  }
}

/**
 * Implements hook_entity_delete.
 *
 */
function psfc_orientation_entity_delete($entity, $type) {
  if($type == 'node' && $entity->type == 'orientation_attendee') {
    $node_wrapper = entity_metadata_wrapper('node', $entity); 
    $offset = 1;
    $orientation_node = $node_wrapper->field_orientation_nid->value();
    // If the orientation still exists, check remaining capacity and open if necessary.
    // (since a new spot is opening up).
    if($orientation_node) {
      psfc_orientation_capacity($orientation_node, TRUE, $offset);
    }
  }
  if ($type == 'node' && $entity->type == 'orientation') {
    // When deleting an orientation, delete all attendee nodes.
    $attendees = psfc_orientation_get_all_attendee_nodes($entity->nid);
    foreach ($attendees as $attendee) {
      // Warn the attendee that the orientation is cancelled.
      $node_wrapper = entity_metadata_wrapper('node', $attendee); 
      $recipient = $node_wrapper->field_email->value();
      $account = $node_wrapper->field_user_id->value();
      if(empty($recipient)) {
        $recipient = $account->mail;
      }
      $params['node'] = $attendee;
      $params['node']->confirm = psfc_orientation_confirm_url($account, 'confirm', NULL, FALSE);
      $params['node']->cancel = psfc_orientation_confirm_url($account, 'cancel', NULL, FALSE);
      drupal_mail('psfc_orientation', 'registration_coop_cancelled', $recipient, language_default(), $params);

      // Delete the attendee node.
      node_delete($attendee->nid);
    }
  }
}

/**
 *  Temporary PSFC admin landing page
 *
 *  TODO: Move this functionality to a better place
 */
function psfc_orientation_temp_admin_land() {
  $output = l('Administer Orientation', 'admin/psfc/orientation');
  return $output;
}

/**
 *  Helper function to return information about an orientation  rule
 *
 * @param $orid
 * Required. The unique id of the orientation repeat rule
 *
 * @return a keyed array with all relevant information about a rule.
 */
function psfc_orientation_get_repeat_rule_info($orid) {
  $result = db_query("SELECT * FROM {psfc_orientation_repeat_rules} WHERE orid = :orid", array(':orid' => $orid));
  return $result->fetchAssoc();
}

/**
 *  Helper function to determine next repeated orienation
 *
 */
function psfc_orientation_determine_next_repeat($time) {
  $two_weeks = strtotime('+ 2 weeks');
  $date = date('Y-m-d', $two_weeks);
  $string = $date . ' ' . $time['hour'] . ':' . $time['minute'] . ' ' . $time['ampm'];
  $next_orientation = strtotime($string);
  return $next_orientation;
}

/**
 * Helper function to split apart the time_of_day saved in orienation_rule
 */
function psfc_orientation_split_time_of_day($orid) {
  $info = psfc_orientation_get_repeat_rule_info($orid);
  $split0 = explode(':', $info['time_of_day']);
  $split1 = explode(' ', $split0[1]);

  $time = array();
  $time['hour'] = $split0[0];
  $time['minute'] = $split1[0];
  $time['ampm'] = $split1[1];

  return $time;
}

/**
 * Wrapper for theme function to display user's orientation status page
 *
 */
function psfc_orientation_status() {
  return theme('psfc_orientation_status');
}

/**
 * Helper function to determine if there is already an orientation scheduled
 * for a time slot
 *
 * @param $time timestamp
 *
 * @return blooean TRUE if there there is an already scheduled orientation
 */
function psfc_orientation_orientation_exists($time) {
  //cleanup time for pdo
  $date = new DateTime("@$time");
  $time = $date->format("Y-m-d H:i:s");
  $sql = 'SELECT COUNT(*) AS count FROM {field_data_field_orientation_date} ort INNER JOIN {node} n ON ort.entity_id = n.nid AND ort.revision_id = n.vid WHERE n.status = 1 AND ort.field_orientation_date_value = :date';
  $query = db_query($sql, array(':date' => $time));
  if ($query->fetchField() > 0) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function to determine if a date is blacked out
 *
 * @param $date a datestring formatted as YYY-MM-DD
 *
 *
 * @return boolean TRUE if $date is blacked out
 */
function psfc_orientation_orientation_blacked_out($date) {
  $date = date("Y-m-d", $date) . ' 00:00:00';
  $sql = 'SELECT blackout_date FROM {psfc_orientation_blackout_days} WHERE blackout_date = :blackout_date';
  $query = db_query($sql, array(':blackout_date' => $date));
  if ($query->fetchField() == $date) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Build an orientation node
 *
 * @param $orientation_rule an orientation rule as built by
 *    psfc_orientation_get_repeat_rule_info().
 *
 * @param $time_value the tiime of the desired orientation in the format:
 *    YYYY-MM-DDTHH:MM:SS
 *
 * @return the node object of the new orientation.
 */
function psfc_orientation_node_build($orientation_rule, $time_value) {
  // Create a wrapper 
  $node = entity_create('node', array('type' => 'orientation'));

  $date_object = new DateTime("@$time_value");

  $node_wrapper = entity_metadata_wrapper('node', $node); 
  // dpm($node_wrapper->getPropertyInfo());
  $node_wrapper->title->set($date_object->format('l, F j'));
  $node_wrapper->status->set(1);
  $node_wrapper->comment->set(0);
  $node_wrapper->promote->set(0);
  $node_wrapper->sticky->set(0);
  $body = variable_get('psfc_orientation_default_description', t('PSFC Orientations are blah blah blah'));
  $node_wrapper->body->set(array('value' => $body, 'format' => 'psfc_html_filter'));
  $node_wrapper->field_orientation_capacity->set($orientation_rule['capacity']);
  $node_wrapper->field_orientation_date->set($date_object->getTimestamp());
  $node_wrapper->field_orientation_closed->set(0);
  $node_wrapper->field_orientation_reminder->set(0);
  
  $node_wrapper->save(); 
  return $node_wrapper;
}


/**
 * Build an attendee node
 *
 * @param $account the attendee user account
 *
 * @param $onid the node id for the orientation the attended will attend.
 * *
 * @return a node wrapper object for the new orientation attendee node.
 */
function psfc_orientation_node_build_attendee($account, $onid) {
  // Create a wrapper for the given user
  $user_wrapper = entity_metadata_wrapper('user', $account);

  // Create a wrapper for the attendee node
  $node = entity_create('node', array('type' => 'orientation_attendee'));

  $node_wrapper = entity_metadata_wrapper('node', $node); 
  // dpm($node_wrapper->getPropertyInfo());
  $node_wrapper->field_user_id->set($account->uid);
  $node_wrapper->title->set($account->name);
  $node_wrapper->status->set(1);
  $node_wrapper->comment->set(0);
  $node_wrapper->promote->set(0);
  $node_wrapper->sticky->set(0);
  
  // Add the user account details to the node
  $node_wrapper->field_first_name->set($user_wrapper->field_fullname->field_firstname->value());
  $node_wrapper->field_last_name->set($user_wrapper->field_fullname->field_lastname->value());
  $node_wrapper->field_orientation_nid->set($onid);
  $node_wrapper->field_user_id->set($account->uid);
  $node_wrapper->field_confirmed_orientation->set(0);
  $node_wrapper->save(); 
  return $node_wrapper;
}

/**
 * Helper function to count open slots in an orientation and close or reopen it.
 *
 * @param $node
 *   Either an orientation node object or node ID.
 * @param $close
 *   If TRUE the orientation node should be closed or opened.
 * @param $offset
 *   The number to modify the count by. When called by hook_entity_delete
 *   one must be added to the count to account for the registrant
 *   that is about to be deleted but has not yet been deleted.
 * @return The number of open spaces remaining for the orientation.
 */
function psfc_orientation_capacity($node, $close = FALSE, $offset = 0) {
  if (!is_object($node)) {
    // We have to reset the node cache to get the latest count.
    $node = node_load($node, NULL, TRUE);
  }
  $node_wrapper = entity_metadata_wrapper('node', $node); 
  $capacity = $node_wrapper->field_orientation_capacity->value();

  // Get count of people registered with phone number.
  $phone_reg_count = 0;
  foreach($node_wrapper->field_orientation_phone_reg->getIterator() as $delta) {
    $phone_reg_count++;
  }
  // Get count of users on the system registered.
  $result = db_query("SELECT COUNT(DISTINCT fuid.field_user_id_uid) FROM {field_data_field_orientation_nid} fnid JOIN {field_data_field_user_id} fuid ON fnid.revision_id = fuid.revision_id AND fnid.entity_id = fuid.entity_id AND fnid.bundle = fuid.bundle WHERE fnid.field_orientation_nid_nid = :nid", array(':nid' => $node->nid)); 
  if ($result->rowCount() == 0) {
    $user_reg_count = 0;
  }
  else {
    $user_reg_count = $result->fetchField();
  }

  // Get count of remaining slots
  $count = $capacity - $phone_reg_count - $user_reg_count + $offset;

  // It's full. Close it if it's not already closed.
  if ($close && $count <= 0 && $node_wrapper->field_orientation_closed->value() == 0) {
    $node_wrapper->field_orientation_closed->set(1); // 0 is open, 1 is closed.
    $node_wrapper->save();
  }

  // TODO: Change to reflect new open/ closed  field structure.
  // It's not full, reopen it if it's not already open.
  if ($close && $count > 0 && $node_wrapper->field_orientation_closed->value() == 1) {
    $node_wrapper->field_orientation_closed->set(0); // 0 is open, 1 is closed.
    $node_wrapper->save();
  }
  return $count;
}

/**
 * Helper function to close past orientations. Called by cron.
 *
 */
function psfc_orientation_close_old() {
  $old = date('Y-m-d H:i:s', REQUEST_TIME - 3600);
  // TODO: Change to reflect new open/ closed  field structure.
  $sql = "SELECT n.nid FROM node n JOIN field_data_field_orientation_closed oc ON n.nid = oc.entity_id JOIN field_data_field_orientation_date od USING(entity_id) WHERE field_orientation_closed_value = 0 AND field_orientation_date_value < :time";
  $result = db_query($sql, array(':time' => $old));
  while ($nid = $result->fetchField()) {
    $node = node_load($nid);
    $node_wrapper = entity_metadata_wrapper('node', $node); 
    $node_wrapper->field_orientation_closed->set(1);
    $node_wrapper->save();
  }
}

/**
 * Helper function to check if user is already signed up for an open orientation.
 *
 * @param $uid
 *   User's uid to check.
 *
 * @return Boolean.
 */
function psfc_orientation_registered($uid) {
  // TODO: Change to reflect new open/ closed  field structure.
  if (db_query("SELECT COUNT(*)
    FROM {field_data_field_orientation_nid} a
    JOIN {node} n
    ON a.entity_id = n.nid
    AND a.revision_id = n.vid
    JOIN {field_data_field_orientation_closed} o
    ON a.field_orientation_nid_nid = o.entity_id
    WHERE o.field_orientation_closed_value = :open_value
    AND n.uid = :userid_uid",
  array(':open_value' => 0, ':userid_uid' => $uid))->fetchField()) {
    return TRUE;
  }
  return FALSE;
}
/**
 * Helper function to check if user is already signed up for a particular
 *  orientation
 *
 * @param $uid
 *   User's uid to check.
 * @param $nid
 *   Orientation nid to check.
 *
 * @return Boolean.
 */
function psfc_orientation_registered_specific($uid, $nid) {
  if (db_query("SELECT COUNT(*) FROM {content_type_orientation_attendee} WHERE field_orientation_nid_nid = :field_orientation_nid_nid AND field_userid_uid = :field_userid_uid", array(':field_orientation_nid_nid' => $nid, ':field_userid_uid' => $uid))->fetchField()) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function to create a signup link for an orientation.
 *
 * @param $nid
 *   The nid of the orientation node.
 *
 * @return A link starting the signup process or a link to the login/register page.
 */
function psfc_orientation_signup_link($nid) {
  global $user;
  // Return link to the orientation.
  if ($user->uid > 0) {
    // TODO Convert "user_load" to "user_load_multiple" if "$user->uid" is other than a uid.
    // To return a single user object, wrap "user_load_multiple" with "array_shift" or equivalent.
    // Example: array_shift(user_load_multiple(array(), $user->uid))
    $account = user_load($user->uid);
    $member_status = $account->member_status;
    if (psfc_orientation_registered_specific($account->uid, $nid)) {
      return '<div class="button-rounded"><span>' . l(t("Orientation Status"), 'join/orientation/status') . '</span></div>';
    }
    elseif ($member_status['orientation']['registered']) {
      return;
    }
    else {
      return '<div class="button-rounded"><span>' . l(t('I want this one'), 'join/orientation/signup/session/' . $nid) . '</span></div>';
    }
  }
  return '<div class="button-rounded"><span>' . l(t('Log in to select'), 'login') . '</span></div>';
}

/**
 * Callback function for the signup link.
 *
 * Let the user review the session details before we save.
 *
 * @param $nid
 *   The nid of the orientation node.
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function psfc_orientation_signup_session($onid) {
  global $user;
  // Is user already signed up?
  if (psfc_orientation_registered($user->uid) ) {
    drupal_goto('join/orientation/status/registered');
  }
  $orientation = node_load($onid);
  $date = strtotime($orientation->field_orientation_date['und'][0]['value']);
  $pdate = date('M j', $date);
  $dow = date('l', $date);
  $time = date('g:iA', $date);
  $tbl = array();
  $tbl['header'] = array('Date', 'Day', 'Time');
  $tbl['rows'] = array(array($pdate, $dow, $time, l('Yes, Register Me', 'join/orientation/signup/session/register/' . $onid)));
  $output = '<div class="confirm-info-text">';
  $output .= t('You have selected the following Orientation Session:');
  $output .= '</div>';

  $output .= '<div class="confirm-info-date">';
  // TODO Please change this theme call to use an associative array for the $variables parameter.
  $output .= theme('table', $tbl);
  $output .= '</div>';

  $output .= '<div class="button-rounded red"><span>';
  $output .= l(t('No, Select Another Date'), 'join/orientation');
  $output .= '</span></div>';
  return $output;
}

/**
 * Callback function for the signup link.
 *
 * Write the registration to the db (add attendee node).
 *
 * @param $nid
 *   The nid of the orientation node.
 *
 */
function psfc_orientation_signup_session_register($onid) {
  global $user;

  // Is user already signed up?
  if (psfc_orientation_registered($user->uid) ) {
    drupal_goto('join/orientation/status');
  }
  // Create the attendee node for the logged in user, if not already registered
  // and there is space.
  if (psfc_orientation_capacity($onid, TRUE) >= 1) {
    global $user;
    psfc_orientation_node_build_attendee($user, $onid);
  }

  // No more spots open for logged in user!
  else {
    drupal_goto('node/' . variable_get('psfc_orientation_orientation_filled', ''));
  }

  // Logged in user is registered.
  drupal_goto('node/' . variable_get('psfc_orientation_confirm_orientation_page', ''));
}

/**
 * Menu callback for attendee confirm and cancel link.
 *
 * @param $uid
 *   Attendee's uid.
 * @param $timestamp
 *   Unix time when link was created.
 * @param $hassed_pass
 *   md5 hash of the attendee's password.
 * @param $action
 *   Confirm or cancel the orientation registration.
 *
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function psfc_orientation_confirm($uid, $timestamp, $hashed_pass, $action) {
  // Check for active user and confirm hashed pass.
  $accounts = user_load_multiple(array($uid), array('status' => 1));
  $account = array_shift($accounts);
  if (is_numeric($uid) && $account) {
    if ($hashed_pass == psfc_orientation_confirm_rehash($account->pass, $timestamp, $account->login)) {
      // Load the attendee node.
      if ($node = psfc_orientation_get_attendee_node($account)) {
        if ($action == 'confirm') {
          $node_wrapper = entity_metadata_wrapper('node', $node); 
          $node_wrapper->field_confirmed_orientation->set(1);
          $node_wrapper->save();
          drupal_set_message("You have been confirmed!");
          drupal_goto('<front>');
        }
        elseif ($action == 'cancel') {
          // show confirm form.
          return drupal_get_form('psfc_orientation_cancel_confirm', $node);
        }
      }
      // Account exists, but no attendee node. This should probably be a page
      // redirect and not a message.
      else {
        drupal_set_message(t('You have not registered for orientation, or your registration has expired or been cancelled.'));
        drupal_goto('<front>');
      }
    }
  }
  //No account or bad link. An attendee will get here if trying to confirm too
  // late. This should probably be a page redirect and not a message.
  drupal_set_message(t('There is no user for the operation you requested.'));
  //drupal_goto('join/orientation');
}

/**
 * Confirm registration cancellation.
 */
function psfc_orientation_cancel_confirm($form, $form_state, $node) {
  $node_wrapper = entity_metadata_wrapper('node', $node); 
  $form['#orientation_attendee_uid'] = $node_wrapper->field_user_id->value()->uid;
  $form['#orientation_attendee_nid'] = $node_wrapper->getIdentifier();
  $question = t('Confirm Your Cancellation');
  $path = '<front>';
  $description = 'Are you sure you want to cancel your registration for new member orientation?<br /><br />';
  $yes = t('Yes, I Want to Cancel My Registration');
  $no = t('No, Please Do Not Cancel');
  return confirm_form($form, $question, $path, $description, $yes, $no, $name = 'confirm_cancellation');
}

/**
 * Confirm registration cancellation form submit.
 */
function psfc_orientation_cancel_confirm_submit($form, $form_state) {
  node_delete($form['#orientation_attendee_nid']);
  drupal_set_message(t("Your registration has been cancelled."));
  drupal_goto('<front>');
}

/**
 * Generate a secure confirm/cancel link.
 *
 * @param $account
 *   Attendee's useraccount.
 * @param $action
 *   Confirm or cancel the orientation registration.
 *
 * @return An absolute link.
 */
function psfc_orientation_confirm_url($account, $action,     $text = 'Click here to @action your orientation.', $l = TRUE) {
  $timestamp = REQUEST_TIME;
  if ($l) {
    return l(t($text, array('@action' => $action)), 'join/orientation/confirm/' . $account->uid . '/' . $timestamp . '/' . psfc_orientation_confirm_rehash($account->pass, $timestamp, $account->login) . '/' . $action, array('absolute' => TRUE));
  }
  // Used to format link for email tokens.
  else {
    return url('join/orientation/confirm/' . $account->uid . '/' . $timestamp . '/' . psfc_orientation_confirm_rehash($account->pass, $timestamp, $account->login) . '/' . $action, array('absolute' => TRUE));
  }
}

/**
 * Generate a hashed password.
 *
 * @param $password
 *   Attendee's password.
 * @param $timestamp
 *   Unix time of registration.
 * @param $login
 *   Unix time of attendee's first login. This was automatically set on reg.
 *
 * @return A hashed password.
 */
function psfc_orientation_confirm_rehash($password, $timestamp, $login) {
  return md5($timestamp . $password . $login);
}

/**
 * Helper function to load single attendee node.
 *
 * @param $account
 *   The attende.
 *
 * @return Node object.
 */
function psfc_orientation_get_attendee_node($account) {
  $result = db_query("SELECT fnid.entity_id FROM {field_data_field_orientation_nid} fnid JOIN {field_data_field_user_id} fuid ON fnid.revision_id = fuid.revision_id AND fnid.entity_id = fuid.entity_id AND fnid.bundle = fuid.bundle WHERE fuid.field_user_id_uid = :field_userid_uid", array(':field_userid_uid' => $account->uid)); 
  if ($result->rowCount() > 0) { 
    while ($nid = $result->fetchField()) { 
      $node = (is_numeric($nid)) ? node_load($nid) : FALSE; 
      return $node; 
    } 
  } 
  return FALSE;
}

/**
 * Get list of attendees for given orientation nid
 *
 * @param $oid 
 *   The nid of the orientation node
 * @return
 *   An array of attendee node objects.
 */
function psfc_orientation_get_all_attendee_nodes($oid) {
  $attendees = array();
  $result = db_query("SELECT entity_id FROM {field_data_field_orientation_nid} WHERE field_orientation_nid_nid = :nid", array(':nid' => $oid)); 
  while ($nid = $result->fetchField()) {
    $attendees[] = node_load($nid);
  }
  return $attendees;
}

/**
 * Theme a table with 1 orientation date.
 * *
 * @param $orientation
 *   The orientation node.
 */
function theme_psfc_orientation_date_table($variables) {
  $date = $variables['date'];
  $headers = array('Date', 'Day', 'Time', '');
  $rows[0] = array(
    array(
      'data' => '<span class = "mon">' . format_date($date, 'custom', 'M') . '</span>' . ' <span class = "date">' . format_date($date, 'custom', 'j') . '</span>',
      'class' => 'first',
    ),
    array(
      'data' => '<span class = "day">' . format_date($date, 'custom', 'l') . '</span>',
    ),
    array(
      'data' => '<span class = "time">' . format_date($date, 'custom', 'g:i') . '</span>' . '<span class = "meridiem">' . format_date($date, 'custom', 'A') . '</span>',
    ),
  );

  // Move the register me to the table if we're on the correct page.
  if (arg(1) == 'orientation' && arg(2) == 'signup') {
    $rows[0][] = array(
      'data' => '<div class="button-rounded"><span>' .  l(t('Yes, Register Me'), 'join/orientation/signup/session/register/' . $orientation->nid) . '</span></div>',
      'class' => 'last',
    );

  }
  // Set runtime back to America/New_York.
  return theme('table', array('header' => $headers, 'rows' => $rows, 'attributes' => array('class' => array('odate-table'))));
}
/**
 * Theme a the user's orientation status page.
 *
 */
function theme_psfc_orientation_status() {
  global $user;
  if (!$user->uid) {
    return t('Please login to the site to check you registration status.');
  }

  if (!$attendee = psfc_orientation_get_attendee_node($user)) {
    $nid = variable_get('psfc_orientation_register', NULL);
    if(is_null($nid)) {
      drupal_message("Sorry! We hit a big when trying to show you the reigstration page.");
      drupal_goto('<front>');
      exit;
    }
    $text = t('You have created a user account, but are not registered for any upcoming Orientations.');
    $link_text = t("Register for Orientation");
    $link = l($link_text, "node/$nid");
    return $text . '<br /><br /><div class="button-rounded"><span>' . $link . '</span></div>';
  }
  $attendee_node_wrapper = entity_metadata_wrapper('node', $attendee);
  $nid = $attendee_node_wrapper->field_orientation_nid->value()->nid;
  $orientation = node_load($nid);

  $output = '<div class="status-info-text">';
  $output .= '<p>' . t('You have signed up for the following Orientation Session:') . '</p>';
  $output .= '</div>';

  $output .= '<div class="status-info-date">';
  $orientation_node_wrapper = entity_metadata_wrapper('node', $orientation);
  $date = $orientation_node_wrapper->field_orientation_date->value();
  $table = array('date' => $date);
  $output .= theme('psfc_orientation_date_table', $table);
  $output .= '</div>';
  if (!$attendee_node_wrapper->field_confirmed_orientation->value()) {
    $output .= '<p>' . t('You are not yet confirmed. You should have received an email with confirmation instructions. You must confirm within 48 hours of registering or you will lose your reserved place.') . '</p>';
  }
  else {
    $output .= '<p>' . t('Your orientation registration is confirmed. ') . '</p>';
  }
  $output .= '<p>' . t('If this is not correct, please cancel and sign up again.');
  $output .= '<div class="button-rounded"><span>' . psfc_orientation_confirm_url($user, 'cancel', 'Cancel Registration') . '</span></div>';
  return $output;
}

/**
 * Helper function to determine if now is the time window to create
 * an orientation
 *
 * @param $time The unix timestamp of an orientation you are looking to create.
 * @param $range Optional The number of minutes after a time that an
 *  orientation should still get created.
 *
 * @return returns TRUE if it is okay to create the orientation
 */
function psfc_orientation_orientation_creation_window($time, $range = 15) {
  // 'l' is day of week, 'G' is 24 hour format of Hour
  if (date('l') == date('l', $time) && date('G') == date('G', $time)) {
    $current_minute = date('i');
    $time_minute = date('i', $time);
    if ($time_minute <= $current_minute && $current_minute <= $time_minute + $range) {
      return TRUE;
    }
  }
  return FALSE;
}
/**
 * Helper function to delete past blackout days via cron
 */
function psfc_orientation_past_blackout_delete() {
  $q = db_query("SELECT * FROM {psfc_orientation_blackout_days}");

  $obids = array();
  while ($r = $q->fetchAssoc()) {
    $date = strtotime($r['blackout_date']);
    if ($date < REQUEST_TIME) {
      $obids[] = $r['obid'];
    }
  }
  foreach ($obids as $key => $obid) {
    // TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query("DELETE FROM {psfc_orientation_blackout_days} WHERE obid = %d", $obid) */
    db_delete('psfc_orientation_blackout_days')
      ->condition('obid', $obid)
      ->execute();
  }
}

/**
 * Helper function to pass a user's orientation status to
 * the member_data module
 *
 * @param $uid The user id for the the member status you are looking for
 *
 * @return A numeric representation of the user/member's orientation status,
 *  0: User has attended a registration
 *  1: User has select and confirmed a registration slot
 *  2: User has selected but not confirmed
 *  3: User has neither selected, confirmed, or completed reg
 */
function psfc_orientation_user_orientation_status($uid) {
  // TODO Convert "user_load" to "user_load_multiple" if "$uid" is other than a uid.
  // To return a single user object, wrap "user_load_multiple" with "array_shift" or equivalent.
  // Example: array_shift(user_load_multiple(array(), $uid))
  $user = user_load($uid);
  $member_status = $user->member_status;
  if (!$member_status['orientation']['registered']) {
    return 3;
  }
  elseif ($member_status['orientation']['confirmed'] == 0) {
    return 2;
  }
  elseif ($member_status['orientation']['confirmed'] == 1    && !$member_status['orientation']['attended']) {
    return 1;
  }
  elseif ($member_status['orientation']['attended'] == 1) {
    return 0;
  }
}

/**
 * Helper function returns number of future orientations that have openings.
 * 
 **/
function psfc_orientation_check_openings() {
  $sql = "SELECT count(nid) FROM {node} n JOIN {field_data_field_orientation_closed} c ON " .
    "n.nid = c.entity_id WHERE c.entity_type = 'node' AND c.bundle = 'orientation' AND ".
    "(field_orientation_closed_value = 0 OR field_orientation_closed_value IS NULL) AND ".
    "n.status = 1"; 
  $result = db_query($sql);
  return $result->fetchField();
}

/*
 * Theme function to return orientation status/workflow breadcrumbs.
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_psfc_orientation_crumbs($variables) {
  $path = $variables['path'];

  // Trim unneeded path elements.
  $path = explode('/', $path);
  $path = array_slice($path, 0, 4);
  $path = implode('/', $path);

  if (!in_array($path, array('join/orientation', 'join/orientation/status', 'node/40', 'join/orientation/signup/session', 'node/43'))) {
    return;
  }

  global $user;
  $status = psfc_orientation_user_orientation_status($user->uid);

  $items = array(
    array(
      'data' => 'Select',
    ),
    array(
      'data' => 'Review',
    ),
    array(
      'data' => 'Confirm',
    ),
    array(
      'data' => 'You are Confirmed',
    ),
  );
  if ($path == 'join/orientation/signup/session') {
    $items[1]['class'] = $status == 1 ? '' : 'active';
  }
  else {
    switch ($status) {
      case 1:
        $items[3]['class'] = 'active';
        break;
      case 2:
        $items[2]['class'] = 'active';
        break;
      case 3:
        $items[0]['class'] = 'active';
        break;
    }
    switch ($path) {
      case 'join/orientation/signup/session':
        $items[1]['class'] = $status == 1 ? '' : 'active';
        break;
    }
  }
  return theme('item_list', array('items' => $items, 'title' => NULL, 'type' => 'ul', 'attributes' => array('id' => 'breadcrumbs')));
}

/*
 * Implements hook_node_operations().
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function psfc_orientation_node_operations() {
  $operations = array(
    'confirm_attendee' => array(
      'label' => t('Confirm attendees'),
      'callback' => 'psfc_orientation_mass_attendee_helper',
      'callback arguments' => array('confirmed' => array('field_attendee_confirmed' => 1)),
    ),
    'unconfirm_attendee' => array(
      'label' => t('Unconfirm attendees'),
      'callback' => 'psfc_orientation_mass_attendee_helper',
      'callback arguments' => array('unconfirmed' => array('field_attendee_confirmed' => 0)),
    ),
  );
  return $operations;
}

/*
 * Mass operations on attendees. Used by VBO.
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function psfc_orientation_mass_attendee_helper($nodes, $context) {
  foreach ($nodes as $nid) {
    $node = node_load($nid);
    if ($node->type == 'orientation_attendee') {
      foreach ($context as $field => $value) {
        $node->{$field}[0]['value'] = $value;
        node_save($node);
        switch ($value) {
          case 0:
            drupal_set_message(t('%name has been unconfirmed to attend.', array('%name' => $node->title)));
            break;
          case 1:
            drupal_set_message(t('%name has been confirmed to attend.', array('%name' => $node->title)));
            break;
        }
      }
    }
  }
}

/**
 * Implementation of hook_node_view_alter 
 **/
function psfc_orientation_node_view_alter(&$build) {
  $build['#post_render'][] = 'psfc_orientation_node_post_render';
}

/**
 * Convert any of our tokens in the node
 *
 **/
function psfc_orientation_node_post_render($markup, $element) {
  return token_replace($markup);
}

/**
 * Display page of upcoming orientations. Menu Call back.
 **/
function psfc_orientation_join_orientation() {
  // Check to see if they have already registered for an orientation
  global $user;
  if (!$attendee = psfc_orientation_get_attendee_node($user)) {
    $display_id = 'default';
    $view_name = 'orientations';
    $views = views_embed_view($view_name, $display_id);
    if(trim(strip_tags($views)) == '') {
      drupal_goto('content/sorry-there-are-no-orientation-sessions-available-time');
    }
    return $views;
  }
  else {
    return psfc_orientation_status();
  }
}
